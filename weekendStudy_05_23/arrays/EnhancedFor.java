package arrays;

public class EnhancedFor {
	public static void main(String[] args) {
		// Enhanced-For문
		// 어떤 배열 또는 collection에서 모든 요소를 사용할 때 편리하다.
		
		String[] names = {"권민석","이소라","류형택","김민희"};
		
		// names 배열의 모든 값을 조회하고 싶을 때
		// 일반 for문을 사용할 경우
		// 배열의 첫 번째 값의 index는 0, 가장 마지막 값의 index는 배열의 크기-1이므로,
		// 0부터 배열의 길이-1까지 반복되는 for문을 만들어 돌린다.
		for (int i = 0; i < names.length; i++) {
			System.out.println(names[i]);
		}
		
		// Enhanced-For문(For each 문이라고도 한다)을 사용할 경우
		// 배열에서 값을 꺼내어 담을 변수 String name을 정의한다.(이름은 마음대로 지어도 된다)
		// 해당 변수가 꺼내질 배열과 함께 for문의 () 부분을 정의한다. 
		// for (변수 : 배열) { ()에서 정의한 변수를 사용하는 수행문; }
		// 배열에서 순서대로 1개씩 값을 꺼내어 변수에 담고, 해당 변수를 사용한 수행문을 실행한다.
		// 주의사항
		// 1. 변수는 반드시 배열에 담긴 값과 같은 타입이어야 한다.
		// 2. 배열에 담겨 있는 값을 변경하거나 삭제하는 수행문을 사용하면 오류가 발생한다.
		for (String name : names) {
			System.out.println(name);
		}
		
		// Enhanced-For문을 사용하는 이유
		// 일반 For문을 배열에 대해 사용할 경우, for문의 반복횟수를 얻기 위해 우리는 배열명.length와 같이 배열의 크기를 구하는 메소드를 함께 사용하게 된다.
		// 이 경우, 우리는 .length 메소드를 for문의 ()안에 한 번만 적었다고 생각하지만 실은 for문이 반복될 때마다 .length 메소드가 실행되게 된다.
		// 배열의 크기가 작을 때는 큰 문제가 없지만, 배열의 크기가 커지면 .length 메소드를 실행하는 것도 컴퓨터에 부담을 줄 수 있다.
		// 그럴 때 부담을 피하기 위해서는 별도로 int limit=names.length; 등의 변수를 미리 설정하고 for문에 해당 변수를 사용해 조건식을 작성해야 한다.
		// 그렇게 되면 결국 for문이 복잡해지고 코드의 가독성이 떨어지는 등의 문제가 발생한다.
		// 그래서 단순히 배열에서 값을 하나씩 꺼내어 작업을 수행해야 하는 경우, 그런 용도에 최적화되어 있는 Enhanced-For문을 사용한다.
		// 대신 Enhanced-For문은 위에서 언급한 주의사항들이 있기 때문에 
		// 어떤 배열에서 순서대로 값을 꺼내어 다른 수행문에 대입하기만 하면 될 때(값을 직접 수정하거나 삭제하지는 않을 때)에만 사용한다.
	}
}
